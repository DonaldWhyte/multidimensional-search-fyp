\chapter{Supplementary Material}
\label{chap:supp-material}
\centerline{\rule{149mm}{.02in}}
\vspace{2cm}

TODO: intro to section

\begin{landscape}

	\section{Multi-dimensional Search Structures}

	\null  % Empty line
	\nointerlineskip  % No skip for prev line
	\vfill
	\let\snewpage \newpage
	\let\newpage \relax
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.35]{figures/md_structure_taxonomy.png}
			\caption{Multi-dimensional Search Structure Taxonomy}
			\label{fig:structure-taxonomy}
		\end{figure}
	\let \newpage \snewpage
	\vfill 
	\break % page break

	\newpage

	\begin{table}
		\centering
		\begin{tabular}{|p{2.8cm}|p{5cm}|p{5cm}|p{5cm}|p{2cm}|}
			\hline
			\textbf{Index Structure} &
			\textbf{Memory Overhead} &
			\textbf{Bucket Method?} &
			\textbf{High-Dimensional Data} &
			\textbf{Complexity} \\
			\hline
			Sequential Scan & Low & No (but since data is stored contiguously, there are minimal I/O operations due to sequential access) & Often better than other structures with high $d$ (but significantly poorer performance with low $d$) & Low \\		
			B${}^{+}$-Tree & Low & Yes & One-dimensional & Low \\
			R-Tree & Moderate & Yes & Poor for $d > 10$ \cite{pyramid-tree} & Moderate \\
			Quadtree & Low with uniformly distributed data, high for skewed data due to unnecessary nodes caused by splitting sparse regions of data space & No & Poor because it tries to use balanced splits \cite{pyramid-tree} & Low \\
			Pyramid Tree & Low & Yes (based on B${}^{+}$-tree) & Good & High \\
			PK-Tree & Moderate & No (but uses similar method to reduce I/O operations) & Good & High \\
			Skip Quadtree & Moderate & No & Untested & Moderate \\
			Quadtreap & Low & No & Untested & Moderate \\
			Splay Quadtree & Moderate & No & Untested & Moderate \\
			\hline
		\end{tabular}
		\caption{Comparison of Dynamic Multi-Dimensional Structures}
		\label{tab:comparison}
	\end{table}

\end{landscape}

\section{Performance Timings}

=ITERATION 1=
TODO: tables showing times for three operations w/ synthetic and clustered data (two tables)

TODO: plots for three operations w/ synthetic and clustered data (6 plots)

=ITERATION 2=
TODO: tables showing times for three operations w/ synthetic and clustered data (two tables)

TODO: plots not in main report (7 plots)

\section{Algortithms and Code Listings}

\begin{lstlisting}[label=lst:hash-float-function, caption=Code to Hash Single 32-bit Floating Point Value (Source code from file \texttt{boost/functional/hash/detail/hash\_float\_generic.hpp} in Boost Library 1.42.0)]
// Copyright 2005-2009 Daniel James.
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

// A general purpose hash function for non-zero floating point values.

inline void hash_float_combine(std::size_t& seed, std::size_t value)
{
    seed ^= value + (seed<<6) + (seed>>2);
}

template <class T>
inline std::size_t float_hash_impl2(T v)
{
    boost::hash_detail::call_frexp<T> frexp;
    boost::hash_detail::call_ldexp<T> ldexp;

    int exp = 0;

    v = frexp(v, &exp);

    // A postive value is easier to hash, so combine the
    // sign with the exponent and use the absolute value.
    if(v < 0) {
        v = -v;
        exp += limits<T>::max_exponent -
            limits<T>::min_exponent;
    }

    // The result of frexp is always between 0.5 and 1, so its
    // top bit will always be 1. Subtract by 0.5 to remove that.
    v -= T(0.5);
    v = ldexp(v, limits<std::size_t>::digits + 1);
    std::size_t seed = static_cast<std::size_t>(v);
    v -= seed;

    // ceiling(digits(T) * log2(radix(T))/ digits(size_t)) - 1;
    std::size_t const length
        = (limits<T>::digits *
                boost::static_log2<limits<T>::radix>::value - 1)
        / limits<std::size_t>::digits;

    for(std::size_t i = 0; i != length; ++i)
    {
        v = ldexp(v, limits<std::size_t>::digits);
        std::size_t part = static_cast<std::size_t>(v);
        v -= part;
        hash_float_combine(seed, part);
    }

    hash_float_combine(seed, exp);

    return seed;
}
\end{lstlisting}