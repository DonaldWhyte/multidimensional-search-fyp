\section{Iteration \#2 -- Pyramid Tree Variants}

In the first iteration, the Pyramid tree showed great promise as an efficient index structure for high-dimensional data. The core limitation of the implementations was that \texttt{delete} operations were dramatically slower than other operations because of its worst case complexity of $O(n^2)$ if memory must be released. This iteration focuses on modifying the Pyramid tree in attempt to maintain the good performance of \texttt{insert} and point queries, but increase \texttt{delete} speed. Iteration 2's objectives are:
\begin{itemize}
	\item Implement variant of the index Pyramid tree and a non-index based Pyramid tree
	\item Implement Splay tree
	\item Implement Splay Pyramid Tree (which uses splay tree as one-dimensional back-end)
	\item Analyse performance of all Pyramid tree variants and determine the best performing one
\end{itemize}

\subsection{Rebuild Index Pyramid Tree}

This variant of the pyramid tree uses a different strategy for releasing memory for unused points. Instead of defragmenting the array by peforming a sequence of array deletions when $R + 1$ elements are marked for deletion, the entire structure is rebuilt. This new cleanup procedure starts by clearing the structure and incrementally building the new structure by only adding points \textit{not} marked for deletion. $n - R$ points will be re-instered and insertion in the worst case is $O(n)$, meaning the worst case complexity of \texttt{delete} is $O((n - R)n)$. The larger $R$ is, the less time it takes to perform this procedure but a larger amount of allocated memory goes unused at a time.

\subsection{Bucket Pyramid Tree}

The Bucket Pyramid Tree implementation does not use a single array to store the points. Instead of buckets containing an array of point indices, it has an arrya of actual points. No clenaup procedure is necessary because the memory for a point is released immediately afer it's removed, by simply erasing it from the corresponding bucket's array. The array deletion is a $O(n)$ peration since the case where a single bucket stores all $n$ points is possible, making \texttt{delete} $O(n)$ in the worst case.

\subsection{Splay Pyramid Tree}

Unlile the other implementations, the Splay Pyramid Tree does not use a hash map as the underyling one-dimensional index structure, but a splay tree. The splay tree is a self-adjusting variant of the binary search tree that uses a \textit{splaying} operation (a heuristic) to allow faster access to recently accessed elements. \cite{splay-tree}. The splaying operation achieves this by performing a series of tree rotations that move a given node up to the root of the tree. Through amortised analysis and empirical experiments, it has been shown splay trees can be more efficient than standard binary trees for a series of non-random operations \cite{splay-tree, TODO}, despite the asymptotic worst case bound being worse than binary search trees.

TODO: more detail about the splay tree, including in-depth algorithms??

Nodes in the Splay Pyramid tree correspond to individual buckets in the Bucket Pyramid Tree, meaning each node can store multiple points. Since the splay tree is implemented as a collection of heap-allocated nodes with pointers to link them, deletions are cheap as a low amount of memory needs to be de-allocated per \texttt{delete} operation. The hope is that this, combined with the self-adjusting nature of the splay tree, will produce a Pyramid Tree implementation that is more efficient for non-random operations.

\subsection{Performance Analysis}

TODO: four structures
	Defragment Index Pyramid Tree
	Rebuild Index Pyramid Tree
	Bucket Pyramid Tree
	Splay Pyramid Tree

TODO: justify WHY no-defrag (batch))Pyramid tree is not being used

\subsection{Evaluation}

TODO
