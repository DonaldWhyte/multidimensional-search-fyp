\section{Iteration \#2 -- Pyramid Tree Variants}

In the first iteration, the Pyramid tree showed great promise as an efficient index structure for high-dimensional data. The core limitation of the implementation was that \texttt{delete} operations were dramatically slower than other operations because of its worst case complexity of $O(n^2)$ when releasing memory. This iteration focuses on modifying the Pyramid tree in attempt to maintain the good performance of \texttt{insert} and point queries, but increase \texttt{delete} speed. Iteration 2's objectives are:
\begin{itemize}
	\item Implement variant of the index Pyramid tree and a non-index based Pyramid tree
	\item Implement Splay tree
	\item Implement Splay Pyramid Tree (which uses splay tree as one-dimensional back-end)
	\item Analyse performance of all Pyramid tree variants and determine the best performing one
\end{itemize}

\subsection{Rebuild Index Pyramid Tree}

TODO

\subsection{Bucket Pyramid Tree}

TODO

\subsection{Splay Pyramid Tree}

Unlile the other implementations, the Splay Pyramid Tree does not use a hash map as the underyling one-dimensional index structure, but a splay tree. The splay tree is a self-adjusting variant of the binary search tree that uses a \textit{splaying} operation (a heuristic) to allow faster access to recently accessed elements. \cite{splay-tree}. The splaying operation achieves this by performing a series of tree rotations that move a given node up to the root of the tree. Through amortised analysis and empirical experiments, it has been shown splay trees can be more efficient than standard binary trees for a series of non-random operations \cite{splay-tree, TODO}, despite the asymptotic worst case bound being worse than binary search trees.

TODO: more detail about the splay tree, including in-depth algorithms??

Nodes in the Splay Pyramid tree correspond to individual buckets in the Bucket Pyramid Tree, meaning each node can store multiple points. Since the splay tree is implemented as a collection of heap-allocated nodes with pointers to link them, deletions are cheap as a low amount of memory needs to be de-allocated per \texttt{delete} operation. The hope is that this, combined with the self-adjusting nature of the splay tree, will produce a Pyramid Tree implementation that is more efficient for non-random operations.

\subsection{Performance Analysis}

TODO: four structures
	Defragment Index Pyramid Tree
	Rebuild Index Pyramid Tree
	Bucket Pyramid Tree
	Splay Pyramid Tree

TODO: justify WHY no-defrag (batch))Pyramid tree is not being used

\subsection{Evaluation}

TODO
