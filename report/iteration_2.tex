\section{Iteration \#2 -- Pyramid Tree Variants}

In the first iteration, the Pyramid tree showed great promise as an efficient index structure for high-dimensional data. The core limitation of the implementation was that \texttt{delete} operations were dramatically slower than other operations because of its worst case complexity of $O(n^2)$ when releasing memory. This iteration focuses on modifying the Pyramid tree in attempt to maintain the good performance of \texttt{insert} and point queries, but increase \texttt{delete} speed. Iteration 2's objectives are:
\begin{itemize}
	\item Implement variant of the index Pyramid tree and a non-index based Pyramid tree
	\item Implement Splay tree
	\item Implement Splay Pyramid Tree (which uses splay tree as one-dimensional back-end)
	\item Analyse performance of all Pyramid tree variants and determine the best performing one
\end{itemize}

\subsection{Rebuild Index Pyramid Tree}

TODO

\subsection{Bucket Pyramid Tree}

TODO

\subsection{Splay Pyramid Tree}

TODO

\subsection{Performance Analysis}

TODO: four structures
	Defragment Index Pyramid Tree
	Rebuild Index Pyramid Tree
	Bucket Pyramid Tree
	Splay Pyramid Tree

TODO: justify WHY no-defrag (batch))Pyramid tree is not being used

\subsection{Evaluation}

TODO
