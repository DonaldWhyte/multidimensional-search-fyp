\section{Parallel Search}

When it is desired to increase the efficiency of some computational task, it is common to consider parallelisation. In the context of multi-dimensional search, this means we want to determine whether or not it's possible to perform the dynamic operations and queries of an index structure in parallel, so that we reduce runtime by solving multiple parts of the problem at once.

\textbf{Multi-core parallelisation} runs tasks in parallel on different CPU cores, which can be achieved by executing a program on multiple processes or threads on the host operating system. While it is possible to parallelise index structures on multi-core processors, prior research appears to focus on many-core (see  \cite{btree-gpu1, btree-gpu2, btree-gpu3, traversing-spatial-indexes-gpu, rtree-gpu1, rtree-gpu2}) and distributed (see \cite{fat-btree, distributed-kd-tree, distributed-md-search}) parallelisation. \textbf{Many-core} parallelisation involve a much larger number of cores than multi-core processors and thus, higher parallelisation. GPUs (graphics processing units) are examples of many-core processors, which can have thousands of cores. Despite GPUs initially being created for real-time graphics, they are increasingly being used for general-purpose computing (GPGPU) \cite{performance-tuning-gpgpu}. \textbf{Distributed computing} achieves parallelisation by having multiple physical machines performing the work, communicating with each other over a network \cite{distributed-systems}.

\textbf{Embarrassingly parallel} is a term used to describe problems which can be easily split up into independent tasks that can be parallelised \cite{designing-parallel-programs}. Queries using sequential scan can be considered embarrassingly parallel, as the linear structure can be partitioned and allocated to multiple processors which each search their own sub-structure \cite{gpu-gems-3}. Many index structures are non-linear, hierarchical structures that use some form of tree. This can make them difficult to parallelise, especially if queries require backtracking (traversing back \textit{up} the tree to take another path). This makes the parallelisation of many search structures incredibly difficult and for some, the level of communication that would be required between each parallel process is so high it dominates the time savings achieved by parallelisation, making it less efficient than a serial implementation.

A good amount of research has been performed on parallelising one-dimensional search structures, especially the B-tree, \cite{btree-gpu1, btree-gpu2, btree-gpu3, fat-btree, multidisk-btree, parallel-btree}. There has also been research into parallel multi-dimensional structures, such as the KDB-tree \cite{traversing-spatial-indexes-gpu} and R-trees \cite{master-client-rtree, parallel-rtree, rtree-gpu1, rtree-gpu2}. Recent years have seen much focus on running search on the GPU. Both the B-tree and R-tree have been successfully parallelised on the GPU and have achieved increased performance \cite{btree-gpu2, rtree-gpu1}. However, these techniques are complex and difficult to implement. It appears that parallelising multi-dimensional, even for small gains in efficiency, requires significant effort.

Furthermore, most of the multi-dimensional index structures which have currently been parallelised in the literature (e.g. R-tree) are known to degenerate when given high dimensional data (see Section \ref{sec:curse-of-dimensionality}). Since this project's focus is high-dimensional data and many of the existing parallel techniques are difficult to implement, especially for a developer with little experience with parallel or GPGPU programming, it has been decided that parallelisation will not be the focus of the project initially. For the first iteration, a serial index structure will be implemented. Depending on future research findings, later iterations may implement parallel index structures (either multi-core or many-core), but for the moment this is not the case.
