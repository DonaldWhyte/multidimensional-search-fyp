\section{Parallel Search}

When it is desired to increase the efficiency of some computational task, it is common to consider parallelisation. In the context of multi-dimensional search, this means we want to determine whether or not it is possible to perform the dynamic operations and queries of an index structure in parallel, so that we reduce runtime by solving multiple parts of the problem simultaneously.

\textit{Multi-core parallelisation} runs tasks in parallel on different CPU cores, which can be achieved by executing a program on multiple processes or threads on the host operating system. While it is possible to parallelise index structures on multi-core processors, prior research appears to focus on many-core (e.g. \cite{btree-gpu1, btree-gpu2, btree-gpu3, traversing-spatial-indexes-gpu, rtree-gpu1, rtree-gpu2}) and distributed (e.g. \cite{fat-btree, distributed-kd-tree, distributed-md-search}) parallelisation. \textit{Many-core} parallelisation involves a much larger number of cores than multi-core processors, achieving higher parallelisation. GPUs (graphics processing units) are examples of many-core processors, which have thousands of cores. GPUs were initially developed for real-time graphics, but they are increasingly being used for general-purpose computing (GPGPU) \cite{performance-tuning-gpgpu}. \textit{Distributed computing} uses multiple physical machines, which communicate with each other over a network, to parallelise computation \cite{distributed-systems}.

\textit{Embarrassingly parallel} is a term used to describe problems which can be easily split up into independent tasks that can be parallelised \cite{designing-parallel-programs}. Queries using sequential scan can be considered embarrassingly parallel, as the linear structure can be partitioned and allocated to multiple processors which each search their own sub-structure \cite{gpu-gems-3}. Many index structures are non-linear, hierarchical structures that use some form of tree. This can make them difficult to parallelise, especially if queries require backtracking (traversing back up the tree to take another path). This makes the parallelisation of many search structures incredibly difficult and for some, the level of communication that would be required between each parallel process is so high it dominates the time savings achieved by parallelisation, making it less efficient than a serial implementation.

A good amount of research has been performed on parallelising one-dimensional search structures, especially the B-tree \cite{btree-gpu1, btree-gpu2, btree-gpu3, fat-btree, multidisk-btree, parallel-btree}. There has also been research into parallel multi-dimensional structures, such as the KDB-tree \cite{traversing-spatial-indexes-gpu} and R-trees \cite{master-client-rtree, parallel-rtree, rtree-gpu1, rtree-gpu2}. Recent years have seen much focus on running search on the GPU. Both the B-tree and R-tree have been successfully parallelised on the GPU and have achieved increased performance \cite{btree-gpu2, rtree-gpu1}. However, these techniques are complex and difficult to implement. It appears that parallelising multi-dimensional, even for small gains in efficiency, requires significant effort.

Furthermore, most of the multi-dimensional index structures which have currently been parallelised in the literature (e.g. R-tree) are known to degenerate when given high dimensional data (see Section \ref{sec:curse-of-dimensionality}). Since this project's focus is high-dimensional data and many of the existing parallel techniques are difficult to implement, especially for a developer with little experience with parallel or GPGPU programming, it has been decided that parallelisation will not be the focus of this project.